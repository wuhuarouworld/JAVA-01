作业

电脑环境：win10  内存16G

根据第一题的测试结果来看：

1.四种GC在内存128m时，全部发生OOM，G1在256m时仍发生OOM

2.堆内存并不是越大越好，也不是越小越好，太小会发生OOM，太大则发生一次GC停顿的时间过长，应该根据充分测试后选择合适的堆内存大小，以此来使资源得到最大化的利用

3.串行，并行和CMSGC在设置Xmx1g的时候吞吐量最大，再增大，吞吐量下降，G1在设置4g堆内存大小时，吞吐量最大，由此可见，在内存大的条件下，G1的优势更加明显

下面时gc的一些总结

**GC**

**1.**为什么要有GC? 内存资源有限
**2.**引用计数-->循环依赖  内存泄漏 内存溢出 
改进：可达性分析 GC roots
可作为可达的对象：1）当前正在执行的方法里的局部变量和输入参数
                 2）活动线程
                 3）所有类的静态字段
                 4）JNI引用
**3.**GC分代  
为什么要分代？ 分代假设：大部分新生对象很快无用，存活时间较长的对象，可能存活更长时间
**4.**GC算法 
复制算法（年轻代）年轻代分了三个区 采用这种算法非常高效
标记清除算法  会产生内存碎片
标记清除整理算法（老年代）

**5.**GC分类
1）串行GC 
年轻代 标记复制算法  老年代 标记清除整理算法
单线程  适合几百兆堆内存的JVM 单核cpu
2）并行GC
年轻代 标记复制算法  老年代 标记清除整理算法  触发STW事件
GC线程数默认为cpu核数
适用于多核服务器 吞吐量优先  
3）CMS（并发）
年轻代 并行的标记复制算法  老年代 并发的标记清除算法
目标：不对老年代垃圾收集时产生过长时间的卡顿 低延迟
不对老年代进行整理 使用空闲列表来管理内存空间的回收（加了中间层）
使用的并发线程数为cpu核数的1/4
六个阶段
1.初始标记 STW 根对象直接引用的对象 被年轻代中所有存活对象所引用的对象
2.并发标记 遍历老年代 标记所有的存活对象
3.并发预处理 卡片标记 在并发标记过程中引用关系发生了变化
4.最终标记 STW 完成老年代所有存活对象的标记
5.并发清除 删除不再使用的对象 回收占用的内存空间
6.并发重置 重置CMS算法相关的内部数据 为下一次GC循环做准备
4）G1
目标：将STW停顿的时间和分布变为可预期且可配置 自适应
划分为多个Region（通常2048个）堆不再分为年轻代和老年代 逻辑上所有的Eden和survivor区合起来就是年轻代 所有old区合起来就是老年代
增量处理： 每次只处理一部分内存块 每次GC暂停会收集所有年轻代的内存块以及部分的老年代的内存块
创新：并发阶段估算每个小堆块存活对象的总数 垃圾最多的小块会被优先收集
5）ZGC
GC最大停顿时间不超过10ms
JDK15后支持win和mac
6）ShennandoahGC 
7）Java8中默认使用的GC是Parallel GC
8）JDK5--8默认使用的是并行GC，JDK9--15默认使用的是G1

**6.**常见GC组合
Serial + Serial Old 单线程低延迟垃圾回收机制
ParNew + CMS 多线程低延迟垃圾回收机制
Parallel Scavenge + Parallel Scavenge Old 多线程高吞吐量来及回收机制

**7.**GC选择
吞吐优先 Parallel GC
低延迟 CMS GC
系统内存堆较大 希望整体平均GC时间可控 G1 GC

**8.**GC算法和实现的演进路线
1）串行-->并行
2）并行-->并发
3）CMS-->G1
4) G1-->ZGC



